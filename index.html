<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
    <title>PUSHPAK AI · MOBILE PHYSICS</title>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "ossos": "https://cdn.jsdelivr.net/npm/ossos@0.0.10/index.js"
            }
        }
    </script>
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --gold: #ffd700;
            --gold-dark: #ff8c00;
            --bg: #0a0a12;
            --glass: rgba(10,10,20,0.85);
            --glass-border: rgba(255,215,0,0.3);
            --error: #ff5555;
            --success: #44ff44;
            --warning: #ffaa44;
            --font: 'Space Grotesk', sans-serif;
        }
        body {
            font-family: var(--font);
            background: var(--bg);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none; /* Prevent browser gestures on canvas */
        }
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        .overlay {
            position: absolute;
            z-index: 10;
            pointer-events: none;
        }
        .overlay * {
            pointer-events: auto;
        }
        /* Top bar – compact */
        .top-bar {
            top: 10px; left: 10px; right: 10px;
            display: flex; justify-content: space-between; align-items: center;
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 50px; padding: 8px 16px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        .logo {
            font-weight: 700; font-size: 1.2rem;
            background: linear-gradient(135deg, var(--gold), var(--gold-dark));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .logo i { margin-right: 4px; }
        .status { display: flex; gap: 8px; font-size: 0.7rem; }
        .status i { margin-right: 2px; }
        .profile { display: flex; gap: 8px; align-items: center; }
        .avatar { width: 30px; height: 30px; border-radius: 50%; background: linear-gradient(135deg, var(--gold), var(--gold-dark)); display: flex; align-items: center; justify-content: center; font-size: 0.9rem; }
        /* Bottom panel – fully responsive grid with larger buttons */
        .bottom-panel {
            bottom: 10px; left: 10px; right: 10px;
            background: var(--glass); backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border); border-radius: 30px;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns on mobile */
            gap: 10px;
            max-height: 50vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        @media (min-width: 600px) {
            .bottom-panel { grid-template-columns: repeat(4, 1fr); }
        }
        @media (min-width: 900px) {
            .bottom-panel { grid-template-columns: repeat(6, 1fr); }
        }
        .bottom-panel button, .bottom-panel select, .bottom-panel span {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,215,0,0.5);
            color: white; padding: 14px 6px; border-radius: 40px;
            font-weight: 600; font-size: 0.9rem; cursor: pointer;
            backdrop-filter: blur(10px); display: inline-flex; align-items: center; justify-content: center;
            gap: 6px; min-width: 0; min-height: 50px; /* Larger touch target */
            transition: 0.2s; border: none; text-align: center;
            word-break: break-word; line-height: 1.2;
        }
        .bottom-panel button i { font-size: 1.2rem; }
        .bottom-panel button:active { background: var(--gold); color: #000; }
        .bottom-panel button:disabled { opacity: 0.3; pointer-events: none; }
        .bottom-panel select { appearance: none; background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ffd700' stroke-width='2'><polyline points='6 9 12 15 18 9'/></svg>"); background-repeat: no-repeat; background-position: right 10px center; padding-right: 24px; }
        .anim-group { display: contents; } /* Let grid handle children */
        #status-msg { background: transparent; border: none; justify-content: flex-start; font-size: 0.8rem; }
        /* Right panel – bottom sheet on mobile */
        .right-panel {
            top: auto; bottom: 80px; right: 10px; left: 10px;
            width: auto; background: var(--glass); backdrop-filter: blur(30px);
            border: 1px solid var(--glass-border); border-radius: 30px;
            padding: 20px; transition: transform 0.3s, opacity 0.3s;
            max-height: 70vh; overflow-y: auto;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.8);
        }
        .right-panel.hidden { transform: translateY(100%); opacity: 0; pointer-events: none; }
        @media (min-width: 768px) {
            .right-panel { top: 120px; bottom: auto; right: 20px; left: auto; width: 320px; }
        }
        .right-panel h3 { color: var(--gold); margin-bottom: 15px; font-size: 1rem; }
        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: flex; justify-content: space-between; color: #ccc; font-size:0.9rem; }
        input[type=range] { width: 100%; accent-color: var(--gold); height: 40px; } /* Larger slider */
        .xp-bar { background: rgba(255,255,255,0.1); height: 8px; border-radius: 4px; margin:15px 0; overflow: hidden; }
        .xp-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--gold), var(--gold-dark)); }
        /* AI chat – compact */
        #ai-chat {
            position: absolute; bottom: 80px; left: 10px; right: 10px;
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--gold); border-radius: 30px; padding: 15px;
            color: white; z-index: 20; max-width: 300px; margin: 0 auto;
        }
        @media (min-width: 768px) {
            #ai-chat { bottom: 150px; left: 30px; right: auto; width: 280px; }
        }
        #ai-chat input {
            width: 100%; padding: 12px; border-radius: 40px;
            border: 1px solid var(--gold); background: rgba(0,0,0,0.3);
            color: white; margin-top: 10px; font-size: 1rem;
        }
        #ai-response { font-size: 0.9rem; margin-top: 10px; min-height: 40px; }
        #skeleton-type { padding: 12px; border-radius: 40px; background: #1a1a2a; color: white; border: 1px solid var(--gold); }
        /* Toast container */
        #toast-container {
            position: fixed; bottom: 20px; right: 10px; left: 10px;
            display: flex; flex-direction: column; gap: 8px; align-items: flex-end;
            pointer-events: none; z-index: 3000;
        }
        .toast {
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid var(--gold); border-radius: 40px;
            padding: 12px 20px; color: white; font-weight: 600; font-size: 0.9rem;
            animation: slideIn 0.3s, fadeOut 0.3s 2.7s forwards;
            max-width: 90%; word-break: break-word;
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeOut { to { opacity: 0; transform: translateX(100%); } }
        #error-boundary {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,20,0.95); backdrop-filter: blur(20px);
            z-index: 2000; display: flex; justify-content: center; align-items: center;
            visibility: hidden; opacity: 0; transition: 0.3s; padding: 20px;
        }
        #error-boundary.show { visibility: visible; opacity: 1; }
        .error-card {
            background: rgba(255,80,80,0.2); border: 2px solid var(--error);
            border-radius: 30px; padding: 25px; max-width: 350px; text-align: center;
        }
        .error-card button {
            margin-top: 20px; padding: 15px 30px; background: var(--error);
            border: none; color: white; border-radius: 40px; font-weight: bold;
            cursor: pointer; width: 100%; font-size: 1rem;
        }
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg); display: flex; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.5s; pointer-events: none;
        }
        #loading.fadeout { opacity: 0; }
        .spinner {
            width: 60px; height: 60px; border: 5px solid rgba(255,215,0,0.2);
            border-top-color: var(--gold); border-radius: 50%; animation: spin 1s infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        #xp-display { font-size: 0.9rem; }
    </style>
</head>
<body>
    <div id="loading"><div class="spinner"></div><div style="margin-top:15px;">PUSHPAK AI</div></div>
    <div id="error-boundary">
        <div class="error-card">
            <i class="fas fa-exclamation-triangle" style="font-size:3rem; color:var(--error);"></i>
            <h2 style="margin:15px 0;">CRITICAL ERROR</h2>
            <p id="error-message">An unexpected error occurred.</p>
            <button onclick="location.reload()">RELOAD</button>
        </div>
    </div>
    <div id="canvas-container"></div>
    <div id="toast-container"></div>

    <!-- Top bar -->
    <div class="overlay top-bar">
        <div class="logo"><i class="fas fa-cube"></i> PUSHPAK</div>
        <div class="status">
            <span><i class="fas fa-circle" id="status-led" style="color:var(--success);"></i> <span id="status-text">ONLINE</span></span>
            <span><i class="fas fa-bolt"></i> <span id="xp-display">0 XP</span></span>
        </div>
        <div class="profile">
            <div class="avatar"><i class="fas fa-user-astronaut"></i></div>
        </div>
    </div>

    <!-- Right panel (manual controls) – hidden by default -->
    <div class="overlay right-panel hidden" id="right-panel">
        <h3><i class="fas fa-hand"></i> MANUAL JOINT CONTROL</h3>
        <select id="bone-select" style="width:100%; margin-bottom:15px;">
            <option value="cube">JELLY CUBE</option>
        </select>
        <div class="slider-group">
            <label>X <span id="rot-x-val">0.0</span></label>
            <input type="range" id="rot-x" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
        <div class="slider-group">
            <label>Y <span id="rot-y-val">0.0</span></label>
            <input type="range" id="rot-y" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
        <div class="slider-group">
            <label>Z <span id="rot-z-val">0.0</span></label>
            <input type="range" id="rot-z" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
        <div class="xp-bar"><div class="xp-fill" id="xp-fill" style="width:0%"></div></div>
        <div style="color:#ccc; font-size:0.9rem;">XP: <span id="xp-count">0</span></div>
    </div>

    <!-- AI Chat -->
    <div id="ai-chat">
        <div style="display: flex; gap: 10px; align-items: center;">
            <i class="fas fa-robot" style="color:var(--gold);"></i>
            <span>AI</span>
        </div>
        <div id="ai-response">Hello!</div>
        <input type="text" id="chat-input" placeholder="Message..." />
    </div>

    <!-- Bottom panel – fully responsive grid with large buttons -->
    <div class="overlay bottom-panel">
        <button id="upload-btn"><i class="fas fa-upload"></i> UPLOAD</button>
        <input type="file" id="file-input" accept=".glb,.gltf" style="display:none;">
        <select id="skeleton-type">
            <option value="biped">Biped</option>
            <option value="quadruped">Quadruped</option>
            <option value="custom">Custom</option>
        </select>
        <button id="apply-ai-mapping"><i class="fas fa-brain"></i> MAP</button>
        <button id="tpose-to-idle"><i class="fas fa-child"></i> IDLE</button>
        <select id="animation-select" disabled>
            <option value="idle">IDLE</option>
            <option value="walk">WALK</option>
            <option value="run">RUN</option>
            <option value="jump">JUMP</option>
        </select>
        <!-- Procedural animation buttons as a group -->
        <button id="anim-wave" disabled><i class="fas fa-hand-peace"></i> WAVE</button>
        <button id="anim-kick" disabled><i class="fas fa-running"></i> KICK</button>
        <button id="anim-dance" disabled><i class="fas fa-music"></i> DANCE</button>
        <button id="anim-walk" disabled><i class="fas fa-walking"></i> WALK</button>
        <button id="anim-run" disabled><i class="fas fa-running"></i> RUN</button>
        <button id="anim-jump" disabled><i class="fas fa-arrow-up"></i> JUMP</button>
        <button id="anim-idle" class="active"><i class="fas fa-clock"></i> IDLE</button>
        <button id="physics-toggle" class="active"><i class="fas fa-heartbeat"></i> PHYSICS</button>
        <button id="manual-toggle"><i class="fas fa-cog"></i> MANUAL</button>
        <button id="camera-lock"><i class="fas fa-lock"></i> CAM</button>
        <button id="reset-btn"><i class="fas fa-undo"></i> RESET</button>
        <span id="status-msg"><i class="fas fa-circle" style="color:var(--success);"></i> READY</span>
    </div>

    <script type="module">
        // ========== GLOBAL ERROR HANDLING ==========
        window.addEventListener('error', (e) => { e.preventDefault(); showFatalError(e.error?.message || e.message); return false; });
        window.addEventListener('unhandledrejection', (e) => { e.preventDefault(); showFatalError(e.reason?.message); });

        let fatalErrorShown = false;
        function showFatalError(msg) {
            if (fatalErrorShown) return;
            fatalErrorShown = true;
            document.getElementById('error-message').innerText = msg || 'Unknown error';
            document.getElementById('error-boundary').classList.add('show');
        }

        // Toast system
        const toastContainer = document.getElementById('toast-container');
        function showToast(msg, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerText = msg;
            toastContainer.appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }

        // ========== IMPORTS WITH FALLBACKS ==========
        let THREE, OrbitControls, GLTFLoader, TransformControls, CANNON, OSOS;
        try {
            THREE = await import('three');
            OrbitControls = (await import('three/addons/controls/OrbitControls.js')).OrbitControls;
            GLTFLoader = (await import('three/addons/loaders/GLTFLoader.js')).GLTFLoader;
            TransformControls = (await import('three/addons/controls/TransformControls.js')).TransformControls;
        } catch (e) { showFatalError('Failed to load Three.js modules.'); }

        try {
            CANNON = await import('cannon-es');
        } catch (e) { console.warn('Cannon-es not available, physics disabled'); }

        try {
            OSOS = (await import('ossos')).default;
            console.log('OSOS loaded');
        } catch (e) {
            console.warn('OSOS not available');
            showToast('OSOS not loaded – procedural only', 'warning');
        }

        // ========== SETUP ==========
        let scene, camera, renderer, controls, transformControls;
        let currentModel = null;
        let bones = [];
        let mixer = null;
        let animations = {};
        let currentAction = null;
        let physicsEnabled = true;
        let xp = 0;
        let fallbackCube = null;
        let isFallback = true;
        let selectedBone;
        let manualMode = false;
        let cameraLocked = false;
        let procAnim = 'idle';
        let procAnimTime = 0;
        let ososArmature = null;
        let ososRig = null;
        const clock = new THREE.Clock();

        // Physics world
        let physicsWorld, physicsCubeBody;
        let dragConstraint = null;
        let mouseBody; // invisible body for dragging
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // UI elements
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const applyAIMapping = document.getElementById('apply-ai-mapping');
        const tposeToIdleBtn = document.getElementById('tpose-to-idle');
        const animSelect = document.getElementById('animation-select');
        const physicsToggle = document.getElementById('physics-toggle');
        const manualToggle = document.getElementById('manual-toggle');
        const cameraLockBtn = document.getElementById('camera-lock');
        const resetBtn = document.getElementById('reset-btn');
        const statusMsg = document.getElementById('status-msg');
        const boneSelect = document.getElementById('bone-select');
        const rotX = document.getElementById('rot-x');
        const rotY = document.getElementById('rot-y');
        const rotZ = document.getElementById('rot-z');
        const rotXval = document.getElementById('rot-x-val');
        const rotYval = document.getElementById('rot-y-val');
        const rotZval = document.getElementById('rot-z-val');
        const xpFill = document.getElementById('xp-fill');
        const xpCount = document.getElementById('xp-count');
        const xpDisplay = document.getElementById('xp-display');
        const rightPanel = document.getElementById('right-panel');
        const skeletonType = document.getElementById('skeleton-type');
        const chatInput = document.getElementById('chat-input');
        const aiResponse = document.getElementById('ai-response');
        const animWave = document.getElementById('anim-wave');
        const animKick = document.getElementById('anim-kick');
        const animDance = document.getElementById('anim-dance');
        const animWalk = document.getElementById('anim-walk');
        const animRun = document.getElementById('anim-run');
        const animJump = document.getElementById('anim-jump');
        const animIdle = document.getElementById('anim-idle');

        function setStatus(msg, type = 'info') {
            const color = type === 'success' ? '#44ff44' : type === 'error' ? '#ff4444' : '#ffaa44';
            statusMsg.innerHTML = `<i class="fas fa-circle" style="color:${color};"></i> ${msg}`;
        }
        function addXP(amount) { xp += amount; xpFill.style.width = Math.min(100, xp) + '%'; xpCount.textContent = xp; xpDisplay.textContent = xp + ' XP'; }

        // ========== SCENE INIT WITH PHYSICS ==========
        function initScene() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a12);
                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(3, 2, 5);
                renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = true;
                controls.maxPolarAngle = Math.PI / 2;
                controls.minDistance = 2;
                controls.maxDistance = 15;
                controls.target.set(0, 1.2, 0);
                controls.enablePan = true;
                controls.enableZoom = true;
                controls.enableRotate = true;
                controls.touchRotate = true;
                controls.touchZoom = true;

                transformControls = new TransformControls(camera, renderer.domElement);
                transformControls.addEventListener('dragging-changed', (e) => { controls.enabled = !e.value && !cameraLocked; });
                scene.add(transformControls);

                // Lights
                scene.add(new THREE.AmbientLight(0x404060, 0.6));
                const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 1024;
                dirLight.shadow.mapSize.height = 1024;
                scene.add(dirLight);
                const fillLight = new THREE.PointLight(0x88aaff, 0.8);
                fillLight.position.set(-4, 3, 5);
                scene.add(fillLight);
                const rimLight = new THREE.PointLight(0xffaa55, 0.6);
                rimLight.position.set(-2, 2, -5);
                scene.add(rimLight);

                // Ground
                const ground = new THREE.Mesh(new THREE.CircleGeometry(12, 32), new THREE.MeshStandardMaterial({ color: 0x1a1a2a, roughness: 0.3 }));
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = 0;
                ground.receiveShadow = true;
                scene.add(ground);
                scene.add(new THREE.GridHelper(20, 20, 0xffd700, 0x553300));

                // Initialize physics world
                if (CANNON) {
                    physicsWorld = new CANNON.World();
                    physicsWorld.gravity.set(0, -9.82, 0);
                    physicsWorld.broadphase = new CANNON.SAPBroadphase(physicsWorld);
                    physicsWorld.defaultContactMaterial.restitution = 0.3;

                    // Ground body
                    const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane() });
                    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                    physicsWorld.addBody(groundBody);

                    // Mouse body for dragging (invisible, static)
                    mouseBody = new CANNON.Body({ mass: 0 });
                    mouseBody.collisionFilterGroup = 0; // no collisions
                    physicsWorld.addBody(mouseBody);
                }

                createJellyCube();
            } catch (e) { showFatalError('3D init failed: ' + e.message); }
        }

        function createJellyCube() {
            try {
                if (currentModel) scene.remove(currentModel);
                currentModel = null; bones = [];
                if (fallbackCube) {
                    scene.remove(fallbackCube);
                    if (physicsWorld && physicsCubeBody) physicsWorld.removeBody(physicsCubeBody);
                }
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0xffaa44, emissive: 0x331100 });
                const cube = new THREE.Mesh(geometry, material);
                cube.castShadow = true; cube.receiveShadow = true;
                cube.position.set(0, 1, 0);
                scene.add(cube);
                fallbackCube = cube; isFallback = true;

                // Create physics body for cube
                if (CANNON && physicsWorld) {
                    const shape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5));
                    physicsCubeBody = new CANNON.Body({ mass: 5, shape: shape });
                    physicsCubeBody.position.set(0, 1, 0);
                    physicsWorld.addBody(physicsCubeBody);
                }

                boneSelect.innerHTML = '<option value="cube">JELLY CUBE</option>';
                boneSelect.disabled = false;
                selectedBone = cube;
                if (manualMode && cube.parent) transformControls.attach(cube);

                tposeToIdleBtn.disabled = false;
                physicsToggle.disabled = false;
                animSelect.disabled = true;
                [animWave, animKick, animDance, animWalk, animRun, animJump].forEach(btn => btn.disabled = true);
                animIdle.disabled = false;
                setProcAnim('idle');
                setStatus('Jelly cube ready – drag it!', 'info');
            } catch (e) { showFatalError('Cube creation failed'); }
        }

        // Bone mapping (simplified)
        const boneMappings = {
            biped: { spine: /spine|chest|torso/i, head: /head|neck/i, leftArm: /leftarm|upperarm_l/i, rightArm: /rightarm|upperarm_r/i, leftLeg: /leftupleg|thigh_l/i, rightLeg: /rightupleg|thigh_r/i, hips: /hips|pelvis|root/i },
            quadruped: { spine: /spine|back/i, head: /head|neck/i, frontLeftLeg: /frontleft|leftfront/i, frontRightLeg: /frontright|rightfront/i, hindLeftLeg: /hindleft|lefthind/i, hindRightLeg: /hindright|righthind/i, tail: /tail/i },
            custom: { spine: /spine|core/i, head: /head|neck/i, limb1: /limb1|arm1/i, limb2: /limb2|arm2/i, limb3: /limb3|leg1/i, limb4: /limb4|leg2/i, tail: /tail|appendage/i }
        };
        function findBone(type, skeleton = 'biped') {
            if (!bones.length) return null;
            const patterns = boneMappings[skeleton] || boneMappings.biped;
            const pattern = patterns[type];
            return pattern ? bones.find(b => pattern.test(b.name.toLowerCase())) : null;
        }

        // ========== DRAGGING WITH RAYCAST AND POINT-TO-POINT CONSTRAINT ==========
        function setupDragging() {
            window.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                if (isFallback && fallbackCube) {
                    const intersects = raycaster.intersectObject(fallbackCube);
                    if (intersects.length > 0 && physicsWorld && physicsCubeBody && CANNON) {
                        controls.enabled = false;
                        const hitPoint = intersects[0].point;
                        mouseBody.position.set(hitPoint.x, hitPoint.y, hitPoint.z);
                        // Create point-to-point constraint between mouse body and cube body
                        dragConstraint = new CANNON.PointToPointConstraint(
                            physicsCubeBody, new CANNON.Vec3(0,0,0),
                            mouseBody, new CANNON.Vec3(0,0,0)
                        );
                        physicsWorld.addConstraint(dragConstraint);
                    }
                }
            });

            window.addEventListener('touchmove', (e) => {
                if (!dragConstraint) return;
                e.preventDefault();
                const touch = e.touches[0];
                const vec = new THREE.Vector3(
                    (touch.clientX / window.innerWidth) * 2 - 1,
                    -(touch.clientY / window.innerHeight) * 2 + 1,
                    0.5
                );
                vec.unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                const distance = camera.position.length(); // keep near camera plane
                const target = camera.position.clone().add(dir.multiplyScalar(distance));
                mouseBody.position.set(target.x, target.y, target.z);
            });

            window.addEventListener('touchend', () => {
                if (dragConstraint) {
                    physicsWorld.removeConstraint(dragConstraint);
                    dragConstraint = null;
                    controls.enabled = !cameraLocked;
                }
            });
        }

        // Model loading
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['glb', 'gltf'].includes(ext)) { showToast('Unsupported format', 'error'); return; }
            if (file.size > 100 * 1024 * 1024) { showToast('File >100MB', 'error'); return; }
            const url = URL.createObjectURL(file);
            loadModel(url, file.name).finally(() => URL.revokeObjectURL(url));
        });

        async function loadModel(url, name) {
            setStatus('Loading...', 'info');
            tposeToIdleBtn.disabled = true; animSelect.disabled = true; physicsToggle.disabled = true;
            [animWave, animKick, animDance, animWalk, animRun, animJump, animIdle].forEach(btn => btn.disabled = true);
            try {
                if (fallbackCube) {
                    scene.remove(fallbackCube);
                    if (physicsWorld && physicsCubeBody) physicsWorld.removeBody(physicsCubeBody);
                    fallbackCube = null;
                }
                const loader = new GLTFLoader();
                const gltf = await new Promise((resolve, reject) => loader.load(url, resolve, undefined, reject));
                currentModel = gltf.scene; scene.add(currentModel);
                const box = new THREE.Box3().setFromObject(currentModel);
                if (box.isEmpty()) throw new Error('Empty model');
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                currentModel.position.copy(center.multiplyScalar(-1)).add(new THREE.Vector3(0, size.y/2, 0));

                bones = [];
                currentModel.traverse(obj => { if (obj.isBone) bones.push(obj); });
                if (bones.length === 0) { showToast('No bones, using cube', 'warning'); createJellyCube(); return; }

                isFallback = false;
                setStatus(`${bones.length} bones`, 'success');
                boneSelect.innerHTML = '<option>Select bone...</option>';
                bones.forEach(b => { let opt = document.createElement('option'); opt.value = b.name; opt.textContent = b.name; boneSelect.appendChild(opt); });
                boneSelect.disabled = false;

                if (OSOS) {
                    try {
                        const armature = new OSOS.Armature();
                        const boneIndices = new Map(bones.map((b,i)=>[b,i]));
                        bones.forEach((bone, idx) => {
                            let parentIdx = bone.parent && boneIndices.has(bone.parent) ? boneIndices.get(bone.parent) : -1;
                            armature.addBone(bone.name, parentIdx, bone.quaternion, bone.position, bone.scale);
                        });
                        let rig = new OSOS.BipedRig();
                        if (rig.autoRig(armature)) { rig.bindPose(armature.getPose()); ososArmature = armature; ososRig = rig; showToast('OSOS rigged', 'success'); }
                        else showToast('OSOS auto‑rig failed', 'warning');
                    } catch (e) { showToast('OSOS error', 'warning'); }
                }

                tposeToIdleBtn.disabled = false; physicsToggle.disabled = false;
                [animWave, animKick, animDance, animWalk, animRun, animJump, animIdle].forEach(btn => btn.disabled = false);
                setProcAnim('idle'); addXP(50);

                if (gltf.animations && gltf.animations.length) {
                    mixer = new THREE.AnimationMixer(currentModel);
                    gltf.animations.forEach(clip => {
                        let name = clip.name.toLowerCase();
                        if (name.includes('idle')) animations.idle = clip;
                        else if (name.includes('walk')) animations.walk = clip;
                        else if (name.includes('run')) animations.run = clip;
                        else if (name.includes('jump')) animations.jump = clip;
                    });
                    if (Object.keys(animations).length) animSelect.disabled = false;
                }
                if (!manualMode) transformControls.detach();
            } catch (err) {
                setStatus('Load failed', 'error'); showToast(err.message, 'error');
                createJellyCube();
            }
        }

        // UI Handlers
        applyAIMapping.addEventListener('click', () => {
            if (!currentModel || isFallback) { showToast('Load a model first', 'warning'); return; }
            showToast('AI mapping simulated', 'success'); addXP(30);
        });

        tposeToIdleBtn.addEventListener('click', () => {
            if (isFallback) { setStatus('Cube idle', 'success'); addXP(30); return; }
            let s = skeletonType.value;
            ['spine','head','leftArm','rightArm','leftLeg','rightLeg'].forEach(part => {
                let bone = findBone(part, s);
                if (bone) {
                    if (part.includes('spine')) bone.rotation.x = 0.1;
                    else if (part.includes('head')) bone.rotation.x = -0.05;
                    else if (part.includes('Arm')) bone.rotation.z = part.includes('left') ? 0.2 : -0.2;
                    else if (part.includes('Leg')) bone.rotation.x = 0.1;
                }
            });
            setStatus('Idle pose', 'success'); addXP(50);
        });

        animSelect.addEventListener('change', () => {
            if (!mixer || !animations[animSelect.value]) { showToast('Anim unavailable', 'warning'); return; }
            setProcAnim('idle');
            if (currentAction) currentAction.stop();
            currentAction = mixer.clipAction(animations[animSelect.value]);
            currentAction.play(); addXP(30);
        });

        physicsToggle.addEventListener('click', () => {
            physicsEnabled = !physicsEnabled;
            physicsToggle.classList.toggle('active', physicsEnabled);
            physicsToggle.innerHTML = physicsEnabled ? '<i class="fas fa-heartbeat"></i> PHYSICS' : '<i class="fas fa-heartbeat"></i> PHYSICS OFF';
        });

        manualToggle.addEventListener('click', () => {
            manualMode = !manualMode;
            manualToggle.classList.toggle('active', manualMode);
            if (manualMode) {
                rightPanel.classList.remove('hidden');
                if (selectedBone && selectedBone.parent) transformControls.attach(selectedBone);
            } else {
                rightPanel.classList.add('hidden');
                transformControls.detach();
            }
        });

        cameraLockBtn.addEventListener('click', () => {
            cameraLocked = !cameraLocked;
            cameraLockBtn.classList.toggle('active', cameraLocked);
            controls.enabled = !cameraLocked;
            cameraLockBtn.innerHTML = cameraLocked ? '<i class="fas fa-lock"></i> CAM' : '<i class="fas fa-unlock-alt"></i> CAM';
        });

        resetBtn.addEventListener('click', () => {
            if (currentModel && !isFallback) {
                currentModel.position.set(0, 1, 0);
                currentModel.rotation.set(0, 0, 0);
                bones.forEach(b => { if (b) b.rotation.set(0, 0, 0); });
            } else if (fallbackCube && physicsCubeBody) {
                fallbackCube.position.set(0, 1, 0);
                fallbackCube.rotation.set(0, 0, 0);
                physicsCubeBody.position.set(0, 1, 0);
                physicsCubeBody.velocity.set(0,0,0);
                physicsCubeBody.angularVelocity.set(0,0,0);
            }
            setProcAnim('idle'); addXP(10); setStatus('Reset', 'success');
        });

        function setProcAnim(anim) {
            procAnim = anim;
            [animWave, animKick, animDance, animWalk, animRun, animJump, animIdle].forEach(btn => btn.classList.remove('active'));
            let btn = anim === 'wave' ? animWave : anim === 'kick' ? animKick : anim === 'dance' ? animDance : anim === 'walk' ? animWalk : anim === 'run' ? animRun : anim === 'jump' ? animJump : animIdle;
            if (btn) btn.classList.add('active');
            procAnimTime = 0;
        }
        animWave.addEventListener('click', () => setProcAnim('wave'));
        animKick.addEventListener('click', () => setProcAnim('kick'));
        animDance.addEventListener('click', () => setProcAnim('dance'));
        animWalk.addEventListener('click', () => setProcAnim('walk'));
        animRun.addEventListener('click', () => setProcAnim('run'));
        animJump.addEventListener('click', () => setProcAnim('jump'));
        animIdle.addEventListener('click', () => setProcAnim('idle'));

        boneSelect.addEventListener('change', (e) => {
            let boneName = e.target.value;
            if (isFallback && boneName === 'cube') {
                selectedBone = fallbackCube;
                if (manualMode && selectedBone?.parent) transformControls.attach(fallbackCube);
                let rot = fallbackCube.rotation;
                rotX.value = rot.x; rotY.value = rot.y; rotZ.value = rot.z;
                rotXval.textContent = rot.x.toFixed(2); rotYval.textContent = rot.y.toFixed(2); rotZval.textContent = rot.z.toFixed(2);
            } else {
                selectedBone = bones.find(b => b.name === boneName);
                if (selectedBone && manualMode && selectedBone.parent) transformControls.attach(selectedBone);
                if (selectedBone) {
                    let rot = selectedBone.rotation;
                    rotX.value = rot.x; rotY.value = rot.y; rotZ.value = rot.z;
                    rotXval.textContent = rot.x.toFixed(2); rotYval.textContent = rot.y.toFixed(2); rotZval.textContent = rot.z.toFixed(2);
                }
            }
        });

        rotX.addEventListener('input', () => { if (selectedBone) { selectedBone.rotation.x = parseFloat(rotX.value); rotXval.textContent = rotX.value; } });
        rotY.addEventListener('input', () => { if (selectedBone) { selectedBone.rotation.y = parseFloat(rotY.value); rotYval.textContent = rotY.value; } });
        rotZ.addEventListener('input', () => { if (selectedBone) { selectedBone.rotation.z = parseFloat(rotZ.value); rotZval.textContent = rotZ.value; } });

        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                let msg = chatInput.value; chatInput.value = '';
                aiResponse.innerHTML = '...';
                setTimeout(() => {
                    let resp = [{ text: "I'm great!", anim: 'dance' }, { text: "Wave!", anim: 'wave' }, { text: "Running!", anim: 'run' }, { text: "Jump!", anim: 'jump' }][Math.floor(Math.random()*4)];
                    aiResponse.innerHTML = resp.text; setProcAnim(resp.anim); addXP(5);
                }, 500);
            }
        });

        // ========== ANIMATION LOOP WITH PHYSICS SYNC ==========
        function animate() {
            requestAnimationFrame(animate);
            try {
                let delta = Math.min(clock.getDelta(), 0.1); // limit delta
                if (physicsWorld) {
                    physicsWorld.step(1/60, delta, 10);
                    // Sync cube visual with physics
                    if (isFallback && fallbackCube && physicsCubeBody) {
                        fallbackCube.position.copy(physicsCubeBody.position);
                        fallbackCube.quaternion.copy(physicsCubeBody.quaternion);
                    }
                }

                if (mixer) mixer.update(delta);

                if (physicsEnabled && !manualMode && !isFallback && currentModel && bones.length) {
                    let chest = findBone('spine', skeletonType.value);
                    if (chest) chest.scale.y = 1 + Math.sin(performance.now() * 0.003)*0.02;
                }

                if (!isFallback && currentModel && bones.length && !manualMode) {
                    procAnimTime += delta;
                    let s = skeletonType.value;
                    let spine = findBone('spine', s), head = findBone('head', s), rArm = findBone('rightArm', s), lArm = findBone('leftArm', s), rLeg = findBone('rightLeg', s), lLeg = findBone('leftLeg', s), hips = findBone('hips', s);

                    switch (procAnim) {
                        case 'wave': if (rArm) { rArm.rotation.z = Math.sin(procAnimTime*8)*0.4+0.2; rArm.rotation.x = Math.sin(procAnimTime*8)*0.2; } if (spine) spine.rotation.y = Math.sin(procAnimTime*8)*0.05; break;
                        case 'kick': if (rLeg) rLeg.rotation.x = Math.sin(procAnimTime*6)*0.6; if (spine) spine.rotation.x = Math.abs(Math.sin(procAnimTime*6))*0.1; break;
                        case 'dance': if (spine) spine.rotation.z = Math.sin(procAnimTime*4)*0.1; if (rArm) rArm.rotation.z = Math.sin(procAnimTime*6)*0.5; if (lArm) lArm.rotation.z = Math.sin(procAnimTime*6+2)*0.5; if (head) head.rotation.z = Math.sin(procAnimTime*4)*0.05; if (hips) hips.rotation.x = Math.sin(procAnimTime*4)*0.05; break;
                        case 'walk': if (rLeg) rLeg.rotation.x = Math.sin(procAnimTime*5)*0.5; if (lLeg) lLeg.rotation.x = Math.sin(procAnimTime*5+Math.PI)*0.5; if (rArm) rArm.rotation.x = Math.sin(procAnimTime*5+Math.PI)*0.4; if (lArm) lArm.rotation.x = Math.sin(procAnimTime*5)*0.4; if (spine) spine.rotation.y = Math.sin(procAnimTime*5)*0.05; if (head) head.rotation.y = Math.sin(procAnimTime*5)*0.03; break;
                        case 'run': if (rLeg) rLeg.rotation.x = Math.sin(procAnimTime*10)*0.8; if (lLeg) lLeg.rotation.x = Math.sin(procAnimTime*10+Math.PI)*0.8; if (rArm) rArm.rotation.x = Math.sin(procAnimTime*10+Math.PI)*0.6; if (lArm) lArm.rotation.x = Math.sin(procAnimTime*10)*0.6; if (spine) spine.rotation.y = Math.sin(procAnimTime*10)*0.1; if (head) head.rotation.y = Math.sin(procAnimTime*10)*0.05; break;
                        case 'jump': let j = Math.sin(procAnimTime*6), squat = Math.max(0,-j)*0.3, lift = Math.max(0,j)*0.3; if (lLeg) lLeg.rotation.x = squat*2; if (rLeg) rLeg.rotation.x = squat*2; if (spine) spine.rotation.x = -squat*0.5; if (hips) hips.position.y = 1 + lift; break;
                        case 'idle': if (spine) spine.rotation.z = Math.sin(procAnimTime*2)*0.02; if (head) head.rotation.z = Math.sin(procAnimTime*2)*0.01; break;
                    }
                }

                controls.update();
                renderer.render(scene, camera);
            } catch (e) { console.error('Anim error', e); }
        }

        window.addEventListener('resize', () => { if (camera && renderer) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });

        initScene();
        setupDragging();
        animate();
        setTimeout(() => document.getElementById('loading').classList.add('fadeout'), 2000);
    </script>
</body>
</html>
