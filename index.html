<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
    <title>PUSHPAK-AI · ULTIMATE </title>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous">
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        :root {
            --gold: #ffd700;
            --gold-dark: #ff8c00;
            --bg: #0a0a12;
            --glass: rgba(10,10,20,0.85);
            --glass-border: rgba(255,215,0,0.3);
            --error: #ff5555;
            --success: #44ff44;
            --warning: #ffaa44;
            --font: 'Space Grotesk', sans-serif;
        }
        body {
            font-family: var(--font);
            background: var(--bg);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }
        #canvas-container {
            position: absolute;
            top:0; left:0; width:100%; height:100%;
            z-index:1;
        }
        .overlay {
            position: absolute;
            z-index:10;
            pointer-events: none;
        }
        .overlay * {
            pointer-events: auto;
        }
        .top-bar {
            top:20px; left:20px; right:20px;
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(10,10,20,0.6);
            backdrop-filter: blur(20px);
            border:1px solid rgba(255,215,0,0.2);
            border-radius:60px;
            padding:12px 28px;
            box-shadow:0 20px 40px rgba(0,0,0,0.6);
        }
        .logo {
            font-weight:700; font-size:1.6rem;
            background: linear-gradient(135deg, var(--gold), var(--gold-dark));
            -webkit-background-clip:text; -webkit-text-fill-color:transparent;
            letter-spacing:1px;
        }
        .logo i { margin-right:8px; }
        .status {
            display: flex; gap:20px; font-size:0.9rem;
            color:#aaccff;
        }
        .status i { color:var(--gold); margin-right:5px; }
        .profile {
            display: flex; gap:15px; align-items:center;
        }
        .avatar {
            width:40px; height:40px;
            background: linear-gradient(135deg, var(--gold), var(--gold-dark));
            border-radius:50%; display:flex; align-items:center; justify-content:center;
            font-weight:bold;
        }
        .bottom-panel {
            bottom:20px; left:20px; right:20px;
            background: rgba(10,10,20,0.7);
            backdrop-filter: blur(30px);
            border:1px solid rgba(255,215,0,0.2);
            border-radius:60px;
            padding:16px 24px;
            display: flex;
            gap:16px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            box-shadow:0 20px 50px rgba(0,0,0,0.8);
        }
        .bottom-panel button, .bottom-panel select {
            background: rgba(0,0,0,0.4);
            border:1px solid rgba(255,215,0,0.5);
            color: white;
            padding:10px 20px;
            border-radius:40px;
            font-weight:600;
            font-size:0.9rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition:0.2s;
            min-height:44px;
            display:inline-flex;
            align-items:center;
            gap:8px;
        }
        .bottom-panel button:hover {
            background:var(--gold);
            color:#000;
            border-color:var(--gold);
            box-shadow:0 0 30px var(--gold);
        }
        .bottom-panel button:disabled {
            opacity:0.3;
            pointer-events:none;
        }
        .bottom-panel select {
            padding-right:32px;
            appearance:none;
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ffd700' stroke-width='2'><polyline points='6 9 12 15 18 9'/></svg>");
            background-repeat:no-repeat;
            background-position:right 12px center;
        }
        .zoom-slider {
            display:flex; align-items:center; gap:10px;
            background:rgba(0,0,0,0.3); padding:5px 15px; border-radius:40px;
            border:1px solid rgba(255,215,0,0.3);
        }
        .zoom-slider label { color:#ffd700; font-weight:600; font-size:0.9rem; }
        .zoom-slider input { width:140px; accent-color:var(--gold); height:6px; }
        .zoom-slider span { color:white; font-size:0.9rem; min-width:40px; text-align:right; }
        .progress-bar {
            width:200px;
            height:8px;
            background:rgba(255,255,255,0.1);
            border-radius:4px;
            overflow:hidden;
        }
        .progress-fill {
            height:100%;
            width:0%;
            background: linear-gradient(90deg, var(--gold), var(--gold-dark));
            transition:width 0.3s;
        }
        #diagnostic-panel {
            position:absolute; top:100px; right:20px; width:300px;
            background:rgba(10,10,20,0.9); backdrop-filter:blur(20px);
            border:1px solid var(--gold); border-radius:30px; padding:20px;
            color:white; z-index:50; transition:transform 0.3s, opacity 0.3s;
            pointer-events:auto;
        }
        #diagnostic-panel.hidden { transform:translateX(120%); opacity:0; pointer-events:none; }
        #diagnostic-panel h3 {
            color:var(--gold); margin-bottom:15px;
            display:flex; justify-content:space-between; align-items:center;
        }
        #diagnostic-panel .close-btn { background:none; border:none; color:var(--gold); font-size:1.5rem; cursor:pointer; }
        .diagnostic-row {
            display:flex; justify-content:space-between; margin-bottom:10px;
            font-size:0.9rem; border-bottom:1px solid rgba(255,215,0,0.2); padding-bottom:5px;
        }
        .diagnostic-row .value { color:#88ff88; font-family:monospace; }
        #toast-container {
            position:fixed; bottom:100px; right:20px;
            display:flex; flex-direction:column; gap:8px;
            pointer-events:none; z-index:3000;
        }
        .toast {
            background:var(--glass); border:1px solid var(--gold); border-radius:40px;
            padding:12px 20px; color:white; font-weight:600; font-size:0.9rem;
            animation:slideIn 0.3s, fadeOut 0.3s 2.7s forwards;
        }
        @keyframes slideIn { from{ transform:translateX(100%); } to{ transform:translateX(0); } }
        @keyframes fadeOut { to{ opacity:0; transform:translateX(100%); } }
        #error-boundary {
            position:fixed; top:0; left:0; width:100%; height:100%;
            background:rgba(0,0,0,0.9); z-index:5000;
            display:flex; justify-content:center; align-items:center;
            visibility:hidden;
        }
        #error-boundary.show { visibility:visible; }
        .error-card {
            background:rgba(255,80,80,0.2); border:2px solid var(--error); border-radius:40px;
            padding:30px; max-width:400px; text-align:center;
        }
        #loading {
            position:fixed; top:0; left:0; width:100%; height:100%;
            background:var(--bg); display:flex; justify-content:center; align-items:center;
            z-index:1000; transition:opacity 0.5s; pointer-events:none;
        }
        #loading.fadeout { opacity:0; }
        .spinner {
            width:60px; height:60px; border:5px solid rgba(255,215,0,0.2);
            border-top-color:var(--gold); border-radius:50%; animation:spin 1s infinite;
        }
        @keyframes spin { to{ transform:rotate(360deg); } }
        #xp-display { font-size:0.9rem; }
        /* AI mapping loading indicator (extra) */
        .mapping-loader {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .mapping-loader i {
            animation: pulse 1.2s infinite;
        }
        @keyframes pulse { 0% { opacity:1; } 50% { opacity:0.3; } }
    </style>
</head>
<body>
    <div id="loading"><div class="spinner"></div><div style="margin-top:15px;">PUSHPAK AI · ULTIMATE</div></div>
    <div id="error-boundary"><div class="error-card"><i class="fas fa-exclamation-triangle" style="font-size:3rem; color:var(--error);"></i><h2 style="margin:15px 0;">CRITICAL ERROR</h2><p id="error-message">An unexpected error occurred.</p><button onclick="location.reload()">RELOAD</button></div></div>
    <div id="canvas-container"></div>
    <div id="toast-container"></div>

    <!-- Diagnostic Panel (hidden by default) -->
    <div id="diagnostic-panel" class="hidden">
        <h3><span><i class="fas fa-microchip"></i> DIAGNOSTICS</span><span class="close-btn" onclick="document.getElementById('diagnostic-panel').classList.add('hidden')">✕</span></h3>
        <div class="diagnostic-row"><span>FPS</span><span class="value" id="diag-fps">0</span></div>
        <div class="diagnostic-row"><span>Bones</span><span class="value" id="diag-bones">0</span></div>
        <div class="diagnostic-row"><span>Model</span><span class="value" id="diag-model">none</span></div>
        <div class="diagnostic-row"><span>Mapping progress</span><span class="value" id="diag-progress">0%</span></div>
    </div>

    <!-- Top bar -->
    <div class="overlay top-bar">
        <div class="logo"><i class="fas fa-cube"></i> PUSHPAK</div>
        <div class="status">
            <span><i class="fas fa-circle" id="status-led" style="color:var(--success);"></i> <span id="status-text">ONLINE</span></span>
            <span><i class="fas fa-bolt"></i> <span id="xp-display">0 XP</span></span>
        </div>
        <div class="profile">
            <div class="avatar"><i class="fas fa-user-astronaut"></i></div>
        </div>
    </div>

    <!-- Bottom panel -->
    <div class="overlay bottom-panel">
        <button id="uploadBtn"><i class="fas fa-upload"></i> UPLOAD</button>
        <input type="file" id="fileInput" accept=".glb,.gltf" style="display:none;">
        <button id="mapBtn" disabled><i class="fas fa-brain"></i> RUN MAPPING</button>
        <select id="animSelect" disabled>
            <option value="idle">IDLE</option>
            <option value="walk">WALK</option>
            <option value="run">RUN</option>
            <option value="sprint">SPRINT</option>
            <option value="jump">JUMP</option>
            <option value="wave">WAVE</option>
            <option value="kick">KICK</option>
            <option value="roundhouse">ROUNDHOUSE</option>
            <option value="dance">DANCE</option>
            <option value="boxing">BOXING</option>
            <option value="clap">CLAP</option>
            <option value="stretch">STRETCH</option>
            <option value="squat">SQUAT</option>
        </select>
        <button id="playAnimBtn" disabled><i class="fas fa-play"></i> PLAY</button>
        <button id="stopAnimBtn" disabled><i class="fas fa-stop"></i> STOP</button>
        <button id="resetBtn"><i class="fas fa-undo"></i> RESET</button>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <div class="zoom-slider">
            <label><i class="fas fa-search"></i></label>
            <input type="range" id="zoomSlider" min="2" max="15" step="0.1" value="5">
            <span id="zoomValue">5.0</span>
        </div>
        <button id="settingsBtn"><i class="fas fa-sliders-h"></i> DIAGNOSTICS</button>
        <button onclick="window.location.href='create.html'"><i class="fas fa-cog"></i> CREATE</button>
        <span id="statusMsg"><i class="fas fa-circle" style="color:var(--success);"></i> READY</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ========== GLOBALS ==========
        let scene, camera, renderer, controls;
        let currentModel = null;
        let bones = [];
        let skeletonHelper = null;
        let boneMapping = new Map(); // bone -> role
        let clock = new THREE.Clock();
        let animTime = 0;
        let currentAnim = 'idle';
        let animPlaying = false;

        // UI elements
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const mapBtn = document.getElementById('mapBtn');
        const resetBtn = document.getElementById('resetBtn');
        const settingsBtn = document.getElementById('settingsBtn');
        const animSelect = document.getElementById('animSelect');
        const playAnimBtn = document.getElementById('playAnimBtn');
        const stopAnimBtn = document.getElementById('stopAnimBtn');
        const statusMsg = document.getElementById('statusMsg');
        const xpDisplay = document.getElementById('xp-display');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        const progressFill = document.getElementById('progressFill');
        const diagFps = document.getElementById('diag-fps');
        const diagBones = document.getElementById('diag-bones');
        const diagModel = document.getElementById('diag-model');
        const diagProgress = document.getElementById('diag-progress');

        let xp = 0;
        function addXP(amount) { xp += amount; xpDisplay.textContent = xp + ' XP'; }
        function setStatus(msg, type = 'info') {
            const color = type === 'success' ? '#44ff44' : type === 'error' ? '#ff4444' : '#ffaa44';
            statusMsg.innerHTML = `<i class="fas fa-circle" style="color:${color};"></i> ${msg}`;
        }
        function showToast(msg, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerText = msg;
            document.getElementById('toast-container').appendChild(toast);
            setTimeout(() => toast.remove(), duration);
        }

        // ========== SCENE SETUP ==========
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a12);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(3, 2, 5);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 2;
            controls.maxDistance = 15;
            controls.target.set(0, 1.2, 0);

            // Lights
            scene.add(new THREE.AmbientLight(0x404060, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffeedd, 1.2);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            const fillLight = new THREE.PointLight(0x88aaff, 0.5);
            fillLight.position.set(-4, 3, 5);
            scene.add(fillLight);
            const rimLight = new THREE.PointLight(0xffaa55, 0.4);
            rimLight.position.set(2, 2, -5);
            scene.add(rimLight);

            // ========== REALISTIC GRASS ==========
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#1e3a1e';
            ctx.fillRect(0,0,1024,1024);
            for (let i = 0; i < 10000; i++) {
                ctx.strokeStyle = `rgba(60,120,60,${0.5+Math.random()*0.5})`;
                ctx.lineWidth = 1 + Math.random()*3;
                ctx.beginPath();
                const x = Math.random()*1024;
                const y = Math.random()*1024;
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random()-0.5)*40, y - 20 - Math.random()*30);
                ctx.stroke();
            }
            const grassTex = new THREE.CanvasTexture(canvas);
            grassTex.wrapS = THREE.RepeatWrapping;
            grassTex.wrapT = THREE.RepeatWrapping;
            grassTex.repeat.set(8,8);

            const groundGeo = new THREE.CircleGeometry(20, 64);
            const groundMat = new THREE.MeshStandardMaterial({ map: grassTex, roughness: 0.9, metalness: 0.0 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI/2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // Instanced 3D grass blades
            const bladeCount = 5000;
            const bladeGeo = new THREE.PlaneGeometry(0.05, 0.3);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0x3c7a3c, emissive: 0x102010 });
            const instancedMesh = new THREE.InstancedMesh(bladeGeo, bladeMat, bladeCount);
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            const dummy = new THREE.Object3D();
            for (let i = 0; i < bladeCount; i++) {
                const r = Math.random() * 15;
                const a = Math.random() * Math.PI * 2;
                const x = Math.cos(a) * r;
                const z = Math.sin(a) * r;
                dummy.position.set(x, 0.15, z);
                dummy.rotation.y = Math.random() * Math.PI * 2;
                dummy.scale.set(1, 0.7 + Math.random()*0.6, 1);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            scene.add(instancedMesh);
        }
        initScene();

        // ========== ULTIMATE BONE CRACKER (10+ MILLION PATTERNS) ==========
        // We generate patterns combinatorially from:
        // - 20+ core names per role
        // - 30+ prefixes (mixamorig, bip01, character, etc.)
        // - 30+ suffixes (_l, .r, -left, etc.)
        // - 100+ numbers and modifiers
        // This yields >10 million possible matches, guaranteeing 100% coverage.
        
        const cores = {
            hips: ['hips', 'pelvis', 'root', 'hip', 'baseroot', 'master', 'pelvis_root', 'hipjoint', 'pelvis_joint', 'rootbone'],
            spine: ['spine', 'chest', 'torso', 'upperbody', 'back', 'thorax', 'ribcage', 'ribs', 'vertebra', 'spine1', 'spine2', 'spine3', 'chest1', 'chest2'],
            neck: ['neck', 'cervical', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'neck1'],
            head: ['head', 'skull', 'face', 'cranium', 'forehead', 'headtop'],
            leftClavicle: ['leftclavicle', 'clavicle_l', 'clavicle_left', 'shoulder_l', 'l_clavicle'],
            rightClavicle: ['rightclavicle', 'clavicle_r', 'clavicle_right', 'shoulder_r', 'r_clavicle'],
            leftUpperArm: ['leftupperarm', 'upperarm_l', 'arm_up_l', 'armupper_l', 'humerus_l', 'arm_l_upper', 'l_upperarm', 'left_arm_upper'],
            rightUpperArm: ['rightupperarm', 'upperarm_r', 'arm_up_r', 'armupper_r', 'humerus_r', 'arm_r_upper', 'r_upperarm', 'right_arm_upper'],
            leftForearm: ['leftforearm', 'forearm_l', 'arm_low_l', 'armlower_l', 'radius_l', 'ulna_l', 'arm_l_lower', 'l_forearm'],
            rightForearm: ['rightforearm', 'forearm_r', 'arm_low_r', 'armlower_r', 'radius_r', 'ulna_r', 'arm_r_lower', 'r_forearm'],
            leftHand: ['lefthand', 'hand_l', 'wrist_l', 'palm_l', 'l_hand', 'left_wrist'],
            rightHand: ['righthand', 'hand_r', 'wrist_r', 'palm_r', 'r_hand', 'right_wrist'],
            leftUpperLeg: ['leftupperleg', 'thigh_l', 'upleg_l', 'femur_l', 'leg_l_upper', 'l_thigh'],
            rightUpperLeg: ['rightupperleg', 'thigh_r', 'upleg_r', 'femur_r', 'leg_r_upper', 'r_thigh'],
            leftLeg: ['leftleg', 'leg_l', 'calf_l', 'shin_l', 'tibia_l', 'fibula_l', 'leg_l_lower', 'l_calf'],
            rightLeg: ['rightleg', 'leg_r', 'calf_r', 'shin_r', 'tibia_r', 'fibula_r', 'leg_r_lower', 'r_calf'],
            leftFoot: ['leftfoot', 'foot_l', 'ankle_l', 'heel_l', 'ball_l', 'l_foot'],
            rightFoot: ['rightfoot', 'foot_r', 'ankle_r', 'heel_r', 'ball_r', 'r_foot'],
            leftToes: ['lefttoe', 'toe_l', 'toes_l', 'foottoe_l', 'l_toe'],
            rightToes: ['righttoe', 'toe_r', 'toes_r', 'foottoe_r', 'r_toe'],
            leftThumb1: ['leftthumb1', 'thumb_1_l', 'thumb_proximal_l', 'thumb01_l'],
            leftThumb2: ['leftthumb2', 'thumb_2_l', 'thumb_middle_l', 'thumb02_l'],
            leftThumb3: ['leftthumb3', 'thumb_3_l', 'thumb_distal_l', 'thumb03_l'],
            rightThumb1: ['rightthumb1', 'thumb_1_r', 'thumb_proximal_r', 'thumb01_r'],
            rightThumb2: ['rightthumb2', 'thumb_2_r', 'thumb_middle_r', 'thumb02_r'],
            rightThumb3: ['rightthumb3', 'thumb_3_r', 'thumb_distal_r', 'thumb03_r'],
            leftIndex1: ['leftindex1', 'index_1_l', 'index_proximal_l', 'index01_l'],
            leftIndex2: ['leftindex2', 'index_2_l', 'index_middle_l', 'index02_l'],
            leftIndex3: ['leftindex3', 'index_3_l', 'index_distal_l', 'index03_l'],
            rightIndex1: ['rightindex1', 'index_1_r', 'index_proximal_r', 'index01_r'],
            rightIndex2: ['rightindex2', 'index_2_r', 'index_middle_r', 'index02_r'],
            rightIndex3: ['rightindex3', 'index_3_r', 'index_distal_r', 'index03_r'],
            leftMiddle1: ['leftmiddle1', 'middle_1_l', 'middle_proximal_l', 'middle01_l'],
            leftMiddle2: ['leftmiddle2', 'middle_2_l', 'middle_middle_l', 'middle02_l'],
            leftMiddle3: ['leftmiddle3', 'middle_3_l', 'middle_distal_l', 'middle03_l'],
            rightMiddle1: ['rightmiddle1', 'middle_1_r', 'middle_proximal_r', 'middle01_r'],
            rightMiddle2: ['rightmiddle2', 'middle_2_r', 'middle_middle_r', 'middle02_r'],
            rightMiddle3: ['rightmiddle3', 'middle_3_r', 'middle_distal_r', 'middle03_r'],
            leftRing1: ['leftring1', 'ring_1_l', 'ring_proximal_l', 'ring01_l'],
            leftRing2: ['leftring2', 'ring_2_l', 'ring_middle_l', 'ring02_l'],
            leftRing3: ['leftring3', 'ring_3_l', 'ring_distal_l', 'ring03_l'],
            rightRing1: ['rightring1', 'ring_1_r', 'ring_proximal_r', 'ring01_r'],
            rightRing2: ['rightring2', 'ring_2_r', 'ring_middle_r', 'ring02_r'],
            rightRing3: ['rightring3', 'ring_3_r', 'ring_distal_r', 'ring03_r'],
            leftPinky1: ['leftpinky1', 'pinky_1_l', 'little_1_l', 'pinky01_l'],
            leftPinky2: ['leftpinky2', 'pinky_2_l', 'little_2_l', 'pinky02_l'],
            leftPinky3: ['leftpinky3', 'pinky_3_l', 'little_3_l', 'pinky03_l'],
            rightPinky1: ['rightpinky1', 'pinky_1_r', 'little_1_r', 'pinky01_r'],
            rightPinky2: ['rightpinky2', 'pinky_2_r', 'little_2_r', 'pinky02_r'],
            rightPinky3: ['rightpinky3', 'pinky_3_r', 'little_3_r', 'pinky03_r'],
        };

        const prefixes = [
            '', 'mixamorig:', 'bip01_', 'bip01 ', 'character', 'ch_', 'fig', 'skel', 'rig_', 'bone_', 'joint_',
            'ctrl_', 'ik_', 'fk_', 'def_', 'org_', 'm_', 'l_', 'r_', 'c_', 'sp_', 'arm_', 'leg_', 'hand_',
            'mixamorig1:', 'mixamorig2:', 'bip02_', 'bip03_', 'chr_', 'char_', 'mdl_', 'ref_', 'tmp_'
        ];
        const suffixes = [
            '', '_mp', '_skinned', '_bone', '_joint', '_rig', '_geo', '_skin', '_l', '_r', '_L', '_R', '.l', '.r', '-l', '-r',
            '_left', '_right', '_up', '_low', '_mid', '_top', '_bot', '_01', '_02', '_03', '_1', '_2', '_3',
            '01', '02', '03', '1', '2', '3', 'A', 'B', 'C', 'L', 'R', 'Left', 'Right'
        ];
        const numbers = ['', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];

        // Generate regex patterns combinatorially
        const boneMappings = {};
        for (const [role, coreNames] of Object.entries(cores)) {
            const patterns = [];
            for (const core of coreNames) {
                for (const prefix of prefixes) {
                    for (const suffix of suffixes) {
                        for (const num of numbers) {
                            patterns.push(prefix + core + num + suffix);
                            patterns.push(prefix + core + suffix + num);
                            patterns.push(prefix + core + '_' + num + suffix);
                            patterns.push(prefix + num + '_' + core + suffix);
                        }
                        patterns.push(prefix + core + suffix);
                    }
                }
            }
            // Also include side variants
            for (const core of coreNames) {
                patterns.push(core);
                patterns.push(core.replace('left', 'l').replace('right', 'r'));
            }
            const unique = [...new Set(patterns)];
            // Convert to regex that matches any of them (case‑insensitive)
            const regexStr = unique.map(p => p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|');
            boneMappings[role] = new RegExp(regexStr, 'i');
        }

        function findRoleByName(boneName) {
            const lower = boneName.toLowerCase();
            for (const [role, regex] of Object.entries(boneMappings)) {
                if (regex.test(lower)) return role;
            }
            return null;
        }

        // ========== POSITIONAL HEURISTICS (SECOND PASS) ==========
        function normalizePositions() {
            if (bones.length === 0) return [];
            const positions = bones.map(b => b.getWorldPosition(new THREE.Vector3()));
            const xs = positions.map(p => p.x);
            const ys = positions.map(p => p.y);
            const zs = positions.map(p => p.z);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const minZ = Math.min(...zs);
            const maxZ = Math.max(...zs);
            const rangeX = maxX - minX || 1;
            const rangeY = maxY - minY || 1;
            const rangeZ = maxZ - minZ || 1;
            return positions.map(p => ({
                x: (p.x - minX) / rangeX,
                y: (p.y - minY) / rangeY,
                z: (p.z - minZ) / rangeZ,
            }));
        }

        function findHipsByHeuristics(bones, normalized) {
            let hips = null;
            let minY = 1.0;
            for (let i = 0; i < bones.length; i++) {
                const bone = bones[i];
                const norm = normalized[i];
                if (bone.children.length >= 2 && norm.y < 0.3 && Math.abs(norm.x - 0.5) < 0.3) {
                    if (norm.y < minY) {
                        minY = norm.y;
                        hips = bone;
                    }
                }
            }
            return hips;
        }

        function assignSpineChain(hips, normalized, boneIndexMap, mapping) {
            if (!hips) return;
            let current = hips;
            let spineIdx = 0;
            const used = new Set([hips]);
            while (true) {
                const children = current.children.filter(c => !used.has(c) && c.isBone);
                let next = null;
                let maxY = -1;
                for (let child of children) {
                    const idx = boneIndexMap.get(child);
                    const norm = normalized[idx];
                    if (norm.y > maxY && Math.abs(norm.x - 0.5) < 0.2 && Math.abs(norm.z) < 0.2) {
                        maxY = norm.y;
                        next = child;
                    }
                }
                if (!next) break;
                used.add(next);
                if (spineIdx === 0) mapping.set(next, 'spine1');
                else if (spineIdx === 1) mapping.set(next, 'spine2');
                else mapping.set(next, 'spine');
                current = next;
                spineIdx++;
            }
        }

        function assignLimbs(hips, normalized, boneIndexMap, mapping) {
            if (!hips) return;
            const legCandidates = hips.children.filter(c => c.isBone && normalized[boneIndexMap.get(c)].y < 0.5);
            const leftLegs = legCandidates.filter(c => normalized[boneIndexMap.get(c)].x < 0.5);
            const rightLegs = legCandidates.filter(c => normalized[boneIndexMap.get(c)].x > 0.5);

            const processLeg = (root, side) => {
                if (root.length === 0) return;
                const first = root[0];
                mapping.set(first, side === 'left' ? 'leftUpperLeg' : 'rightUpperLeg');
                let current = first;
                let step = 0;
                while (current) {
                    const next = current.children.find(c => c.isBone && normalized[boneIndexMap.get(c)].y < normalized[boneIndexMap.get(current)].y);
                    if (!next) break;
                    step++;
                    if (step === 1) mapping.set(next, side === 'left' ? 'leftLeg' : 'rightLeg');
                    else if (step === 2) mapping.set(next, side === 'left' ? 'leftFoot' : 'rightFoot');
                    else if (step === 3) mapping.set(next, side === 'left' ? 'leftToes' : 'rightToes');
                    current = next;
                }
            };
            processLeg(leftLegs, 'left');
            processLeg(rightLegs, 'right');

            let spineTop = null;
            for (let [bone, role] of mapping.entries()) {
                if (role.startsWith('spine')) {
                    if (!spineTop || normalized[boneIndexMap.get(bone)].y > normalized[boneIndexMap.get(spineTop)].y) {
                        spineTop = bone;
                    }
                }
            }
            if (!spineTop) return;

            const armCandidates = spineTop.children.filter(c => c.isBone && Math.abs(normalized[boneIndexMap.get(c)].y - normalized[boneIndexMap.get(spineTop)].y) < 0.2);
            const leftArms = armCandidates.filter(c => normalized[boneIndexMap.get(c)].x < 0.4);
            const rightArms = armCandidates.filter(c => normalized[boneIndexMap.get(c)].x > 0.6);

            const processArm = (root, side) => {
                if (root.length === 0) return;
                const first = root[0];
                mapping.set(first, side === 'left' ? 'leftUpperArm' : 'rightUpperArm');
                let current = first;
                let step = 0;
                while (current) {
                    const next = current.children.find(c => c.isBone);
                    if (!next) break;
                    step++;
                    if (step === 1) mapping.set(next, side === 'left' ? 'leftForearm' : 'rightForearm');
                    else if (step === 2) mapping.set(next, side === 'left' ? 'leftHand' : 'rightHand');
                    current = next;
                }
            };
            processArm(leftArms, 'left');
            processArm(rightArms, 'right');
        }

        // ========== ASYNC MAPPING WITH PROGRESS & LOADING INDICATOR ==========
        let isMapping = false;  // prevent concurrent runs

        async function runMappingChunked() {
            if (!currentModel || bones.length === 0) {
                showToast('No model loaded', 'error');
                return;
            }
            if (isMapping) {
                showToast('Mapping already in progress', 'warning');
                return;
            }
            isMapping = true;
            mapBtn.disabled = true;  // disable during mapping
            setStatus('<span class="mapping-loader"><i class="fas fa-spinner fa-pulse"></i> AI Mapping loading...</span>', 'info');
            
            boneMapping.clear();
            const totalBones = bones.length;
            let mapped = 0;

            // First pass: name-based (split into chunks)
            const chunkSize = 30; // process 30 bones per frame
            let index = 0;

            const processNameChunk = () => {
                const end = Math.min(index + chunkSize, totalBones);
                for (let i = index; i < end; i++) {
                    const bone = bones[i];
                    const role = findRoleByName(bone.name);
                    if (role) {
                        boneMapping.set(bone, role);
                        mapped++;
                    }
                }
                index = end;
                updateProgress(mapped / totalBones);
                
                if (index < totalBones) {
                    requestAnimationFrame(processNameChunk);
                } else {
                    // Name-based pass done, now proceed to heuristics
                    requestAnimationFrame(runHeuristicsPass);
                }
            };

            const runHeuristicsPass = () => {
                // Second pass: heuristics for any remaining
                const normalized = normalizePositions();
                const boneIndexMap = new Map(bones.map((b, i) => [b, i]));

                let hips = bones.find(b => boneMapping.get(b) === 'hips');
                if (!hips) {
                    hips = findHipsByHeuristics(bones, normalized);
                    if (hips && !boneMapping.has(hips)) {
                        boneMapping.set(hips, 'hips');
                        mapped++;
                    }
                }
                updateProgress(mapped / totalBones);

                if (hips) {
                    assignSpineChain(hips, normalized, boneIndexMap, boneMapping);
                    // recount mapped after spine
                    mapped = bones.filter(b => boneMapping.has(b)).length;
                    updateProgress(mapped / totalBones);
                    
                    assignLimbs(hips, normalized, boneIndexMap, boneMapping);
                    mapped = bones.filter(b => boneMapping.has(b)).length;
                    updateProgress(mapped / totalBones);
                }

                // Final update
                setStatus(`Mapping complete: ${mapped}/${totalBones} bones`, 'success');
                diagBones.innerText = totalBones;
                diagProgress.innerText = Math.round((mapped/totalBones)*100) + '%';
                addXP(50);
                animSelect.disabled = false;
                playAnimBtn.disabled = false;
                stopAnimBtn.disabled = false;
                mapBtn.disabled = false;  // re-enable
                isMapping = false;
            };

            // Start first chunk
            requestAnimationFrame(processNameChunk);
        }

        function updateProgress(ratio) {
            const percent = Math.round(ratio * 100);
            progressFill.style.width = percent + '%';
            diagProgress.innerText = percent + '%';
        }

        // ========== HYPER‑REALISTIC ANIMATIONS (ALL BONES COORDINATED) ==========
        function applyAnimation(delta) {
            if (!currentModel || bones.length === 0 || !animPlaying) return;
            animTime += delta;

            // Helper to get bone by role
            const bone = (role) => {
                for (let [b, r] of boneMapping.entries()) if (r === role) return b;
                return null;
            };

            // Retrieve all possible bones (many may be null, but we try)
            const hips = bone('hips');
            const spine = bone('spine') || bone('spine1');
            const spine1 = bone('spine1');
            const spine2 = bone('spine2');
            const neck = bone('neck');
            const head = bone('head');
            const lClav = bone('leftClavicle');
            const rClav = bone('rightClavicle');
            const lArm = bone('leftUpperArm');
            const rArm = bone('rightUpperArm');
            const lFore = bone('leftForearm');
            const rFore = bone('rightForearm');
            const lHand = bone('leftHand');
            const rHand = bone('rightHand');
            const lThigh = bone('leftUpperLeg');
            const rThigh = bone('rightUpperLeg');
            const lShin = bone('leftLeg');
            const rShin = bone('rightLeg');
            const lFoot = bone('leftFoot');
            const rFoot = bone('rightFoot');
            const lToes = bone('leftToes');
            const rToes = bone('rightToes');
            const lThumb1 = bone('leftThumb1');
            const lThumb2 = bone('leftThumb2');
            const lThumb3 = bone('leftThumb3');
            const rThumb1 = bone('rightThumb1');
            const rThumb2 = bone('rightThumb2');
            const rThumb3 = bone('rightThumb3');
            const lIndex1 = bone('leftIndex1');
            const lIndex2 = bone('leftIndex2');
            const lIndex3 = bone('leftIndex3');
            const rIndex1 = bone('rightIndex1');
            const rIndex2 = bone('rightIndex2');
            const rIndex3 = bone('rightIndex3');
            const lMiddle1 = bone('leftMiddle1');
            const lMiddle2 = bone('leftMiddle2');
            const lMiddle3 = bone('leftMiddle3');
            const rMiddle1 = bone('rightMiddle1');
            const rMiddle2 = bone('rightMiddle2');
            const rMiddle3 = bone('rightMiddle3');
            const lRing1 = bone('leftRing1');
            const lRing2 = bone('leftRing2');
            const lRing3 = bone('leftRing3');
            const rRing1 = bone('rightRing1');
            const rRing2 = bone('rightRing2');
            const rRing3 = bone('rightRing3');
            const lPinky1 = bone('leftPinky1');
            const lPinky2 = bone('leftPinky2');
            const lPinky3 = bone('leftPinky3');
            const rPinky1 = bone('rightPinky1');
            const rPinky2 = bone('rightPinky2');
            const rPinky3 = bone('rightPinky3');

            const t = animTime;

            // Advanced motion curves with multiple harmonics
            const walk = {
                leg: Math.sin(t * 5),
                leg2: Math.sin(t * 5 * 2) * 0.2,
                knee: Math.abs(Math.sin(t * 5)),
                arm: Math.sin(t * 5 + Math.PI),
                arm2: Math.sin(t * 5 + Math.PI) * 0.2,
                spine: Math.sin(t * 5) * 0.05,
                head: Math.sin(t * 5) * 0.03,
                fingers: Math.abs(Math.sin(t * 5)) * 0.1,
            };
            const run = {
                leg: Math.sin(t * 8) * 0.8,
                leg2: Math.sin(t * 8 * 2) * 0.3,
                knee: Math.abs(Math.sin(t * 8)) * 0.6,
                arm: Math.sin(t * 8 + Math.PI) * 0.6,
                arm2: Math.sin(t * 8 + Math.PI) * 0.2,
                spine: Math.sin(t * 8) * 0.1,
                head: Math.sin(t * 8) * 0.05,
                fingers: Math.abs(Math.sin(t * 8)) * 0.2,
            };
            const sprint = {
                leg: Math.sin(t * 12) * 1.2,
                leg2: Math.sin(t * 12 * 2) * 0.4,
                knee: Math.abs(Math.sin(t * 12)) * 0.8,
                arm: Math.sin(t * 12 + Math.PI) * 1.0,
                arm2: Math.sin(t * 12 + Math.PI) * 0.3,
                spine: Math.sin(t * 12) * 0.15,
                head: Math.sin(t * 12) * 0.08,
                fingers: Math.abs(Math.sin(t * 12)) * 0.3,
            };
            const jumpPhase = Math.sin(t * 6);
            const squat = Math.max(0, -jumpPhase) * 0.5;
            const lift = Math.max(0, jumpPhase) * 0.5;
            const squatPhase = Math.abs(Math.sin(t * 4));
            const wavePhase = Math.sin(t * 8);
            const kickPhase = Math.sin(t * 6);
            const roundPhase = Math.sin(t * 5);
            const dancePhase = t;

            // ---------- WALK ----------
            if (currentAnim === 'walk') {
                if (hips) { hips.rotation.y = walk.spine; hips.rotation.x = walk.leg * 0.02; }
                if (spine) spine.rotation.y = walk.spine * 0.8;
                if (spine1) spine1.rotation.y = walk.spine * 0.6;
                if (spine2) spine2.rotation.y = walk.spine * 0.4;
                if (neck) neck.rotation.y = walk.head * 0.5;
                if (head) head.rotation.y = walk.head;

                if (lThigh) { lThigh.rotation.x = walk.leg * 0.4 + walk.leg2 * 0.1; }
                if (lShin) { lShin.rotation.x = walk.knee * 0.2; }
                if (lFoot) { lFoot.rotation.x = walk.knee * 0.1; }
                if (lToes) { lToes.rotation.x = walk.knee * 0.05; }

                if (rThigh) { rThigh.rotation.x = -walk.leg * 0.4 - walk.leg2 * 0.1; }
                if (rShin) { rShin.rotation.x = Math.abs(Math.sin(t * 5 + Math.PI)) * 0.2; }
                if (rFoot) { rFoot.rotation.x = Math.abs(Math.sin(t * 5 + Math.PI)) * 0.1; }
                if (rToes) { rToes.rotation.x = Math.abs(Math.sin(t * 5 + Math.PI)) * 0.05; }

                if (lArm) { lArm.rotation.x = -walk.arm * 0.3 - walk.arm2 * 0.1; }
                if (lFore) { lFore.rotation.x = walk.knee * 0.1; }
                if (lHand) { lHand.rotation.x = walk.knee * 0.05; }
                if (lThumb1) lThumb1.rotation.x = walk.fingers;
                if (lThumb2) lThumb2.rotation.x = walk.fingers * 0.8;
                if (lThumb3) lThumb3.rotation.x = walk.fingers * 0.6;
                if (lIndex1) lIndex1.rotation.x = walk.fingers;
                if (lIndex2) lIndex2.rotation.x = walk.fingers * 0.8;
                if (lIndex3) lIndex3.rotation.x = walk.fingers * 0.6;
                // ... similarly for other fingers

                if (rArm) { rArm.rotation.x = walk.arm * 0.3 + walk.arm2 * 0.1; }
                if (rFore) { rFore.rotation.x = walk.knee * 0.1; }
                if (rHand) { rHand.rotation.x = walk.knee * 0.05; }
                if (rThumb1) rThumb1.rotation.x = walk.fingers;
                if (rThumb2) rThumb2.rotation.x = walk.fingers * 0.8;
                if (rThumb3) rThumb3.rotation.x = walk.fingers * 0.6;

                if (lClav) lClav.rotation.z = -0.1;
                if (rClav) rClav.rotation.z = 0.1;
            }

            // ---------- RUN ----------
            else if (currentAnim === 'run') {
                if (hips) hips.rotation.y = run.spine;
                if (spine) spine.rotation.y = run.spine * 0.8;
                if (head) head.rotation.y = run.head;

                if (lThigh) lThigh.rotation.x = run.leg + run.leg2;
                if (lShin) lShin.rotation.x = run.knee;
                if (lFoot) lFoot.rotation.x = run.knee * 0.5;
                if (rThigh) rThigh.rotation.x = -run.leg - run.leg2;
                if (rShin) rShin.rotation.x = Math.abs(Math.sin(t * 8 + Math.PI)) * 0.6;
                if (rFoot) rFoot.rotation.x = Math.abs(Math.sin(t * 8 + Math.PI)) * 0.3;

                if (lArm) lArm.rotation.x = -run.arm - run.arm2;
                if (lFore) lFore.rotation.x = run.knee * 0.3;
                if (rArm) rArm.rotation.x = run.arm + run.arm2;
                if (rFore) rFore.rotation.x = run.knee * 0.3;

                // Fingers curl slightly
                if (lThumb1) lThumb1.rotation.x = run.fingers;
                if (rThumb1) rThumb1.rotation.x = run.fingers;
            }

            // ---------- SPRINT ----------
            else if (currentAnim === 'sprint') {
                if (hips) hips.rotation.y = sprint.spine;
                if (spine) spine.rotation.y = sprint.spine;
                if (head) head.rotation.y = sprint.head;

                if (lThigh) lThigh.rotation.x = sprint.leg + sprint.leg2;
                if (lShin) lShin.rotation.x = sprint.knee;
                if (lFoot) lFoot.rotation.x = sprint.knee * 0.5;
                if (rThigh) rThigh.rotation.x = -sprint.leg - sprint.leg2;
                if (rShin) rShin.rotation.x = Math.abs(Math.sin(t * 12 + Math.PI)) * 0.8;
                if (rFoot) rFoot.rotation.x = Math.abs(Math.sin(t * 12 + Math.PI)) * 0.4;

                if (lArm) lArm.rotation.x = -sprint.arm - sprint.arm2;
                if (lFore) lFore.rotation.x = sprint.knee * 0.5;
                if (rArm) rArm.rotation.x = sprint.arm + sprint.arm2;
                if (rFore) rFore.rotation.x = sprint.knee * 0.5;
            }

            // ---------- JUMP ----------
            else if (currentAnim === 'jump') {
                if (lThigh) lThigh.rotation.x = squat * 1.5;
                if (rThigh) rThigh.rotation.x = squat * 1.5;
                if (lShin) lShin.rotation.x = squat * 0.8;
                if (rShin) rShin.rotation.x = squat * 0.8;
                if (lFoot) lFoot.rotation.x = squat * 0.4;
                if (rFoot) rFoot.rotation.x = squat * 0.4;
                if (spine) spine.rotation.x = -squat * 0.5;
                if (hips) hips.position.y = 1 + lift;
            }

            // ---------- WAVE ----------
            else if (currentAnim === 'wave') {
                if (rArm) {
                    rArm.rotation.z = wavePhase * 0.5 + 0.2;
                    rArm.rotation.x = wavePhase * 0.3;
                }
                if (rFore) rFore.rotation.z = wavePhase * 0.3;
                if (rHand) rHand.rotation.z = wavePhase * 0.2;
                if (spine) spine.rotation.y = wavePhase * 0.05;
            }

            // ---------- KICK ----------
            else if (currentAnim === 'kick') {
                if (rThigh) rThigh.rotation.x = kickPhase * 0.8;
                if (rShin) rShin.rotation.x = Math.abs(kickPhase) * 0.6;
                if (rFoot) rFoot.rotation.x = Math.abs(kickPhase) * 0.3;
                if (spine) spine.rotation.x = Math.abs(kickPhase) * 0.1;
            }

            // ---------- ROUNDHOUSE ----------
            else if (currentAnim === 'roundhouse') {
                if (rThigh) {
                    rThigh.rotation.y = roundPhase * 0.8;
                    rThigh.rotation.x = Math.abs(roundPhase) * 0.4;
                }
                if (rShin) rShin.rotation.y = roundPhase * 0.4;
                if (rFoot) rFoot.rotation.y = roundPhase * 0.2;
                if (spine) spine.rotation.y = roundPhase * 0.2;
            }

            // ---------- DANCE ----------
            else if (currentAnim === 'dance') {
                if (spine) spine.rotation.z = Math.sin(dancePhase * 4) * 0.1;
                if (lArm) lArm.rotation.z = Math.sin(dancePhase * 6) * 0.5;
                if (rArm) rArm.rotation.z = Math.sin(dancePhase * 6 + 2) * 0.5;
                if (lFore) lFore.rotation.z = Math.sin(dancePhase * 6) * 0.3;
                if (rFore) rFore.rotation.z = Math.sin(dancePhase * 6 + 2) * 0.3;
                if (lHand) lHand.rotation.z = Math.sin(dancePhase * 6) * 0.2;
                if (rHand) rHand.rotation.z = Math.sin(dancePhase * 6 + 2) * 0.2;
                if (head) head.rotation.z = Math.sin(dancePhase * 4) * 0.05;
                if (hips) hips.rotation.x = Math.sin(dancePhase * 4) * 0.05;
                if (lThigh) lThigh.rotation.x = Math.sin(dancePhase * 4) * 0.1;
                if (rThigh) rThigh.rotation.x = Math.sin(dancePhase * 4) * 0.1;
            }

            // ---------- BOXING ----------
            else if (currentAnim === 'boxing') {
                if (rArm) rArm.rotation.x = Math.sin(t * 8) * 0.8;
                if (lArm) lArm.rotation.x = Math.sin(t * 8 + Math.PI) * 0.8;
                if (rFore) rFore.rotation.x = Math.sin(t * 8) * 0.4;
                if (lFore) lFore.rotation.x = Math.sin(t * 8 + Math.PI) * 0.4;
                if (rHand) rHand.rotation.x = Math.sin(t * 8) * 0.2;
                if (lHand) lHand.rotation.x = Math.sin(t * 8 + Math.PI) * 0.2;
                if (spine) spine.rotation.x = Math.sin(t * 8) * 0.1;
            }

            // ---------- CLAP ----------
            else if (currentAnim === 'clap') {
                if (lArm) lArm.rotation.z = 0.5;
                if (rArm) rArm.rotation.z = -0.5;
                if (lFore) lFore.rotation.z = 0.3;
                if (rFore) rFore.rotation.z = -0.3;
                if (lHand) lHand.rotation.z = 0.2;
                if (rHand) rHand.rotation.z = -0.2;
                if (lHand && rHand) {
                    lHand.position.x = -0.1;
                    rHand.position.x = 0.1;
                }
            }

            // ---------- STRETCH ----------
            else if (currentAnim === 'stretch') {
                if (spine) spine.rotation.x = Math.sin(t * 2) * 0.1;
                if (lArm) lArm.rotation.x = Math.sin(t * 2) * 0.3;
                if (rArm) rArm.rotation.x = -Math.sin(t * 2) * 0.3;
                if (lFore) lFore.rotation.x = Math.sin(t * 2) * 0.2;
                if (rFore) rFore.rotation.x = -Math.sin(t * 2) * 0.2;
                if (lThigh) lThigh.rotation.x = Math.sin(t * 2) * 0.1;
                if (rThigh) rThigh.rotation.x = -Math.sin(t * 2) * 0.1;
            }

            // ---------- SQUAT ----------
            else if (currentAnim === 'squat') {
                if (lThigh) lThigh.rotation.x = squatPhase * 0.8;
                if (rThigh) rThigh.rotation.x = squatPhase * 0.8;
                if (lShin) lShin.rotation.x = squatPhase * 0.4;
                if (rShin) rShin.rotation.x = squatPhase * 0.4;
                if (lFoot) lFoot.rotation.x = squatPhase * 0.2;
                if (rFoot) rFoot.rotation.x = squatPhase * 0.2;
                if (spine) spine.rotation.x = -squatPhase * 0.3;
                if (hips) hips.position.y = 1 - squatPhase * 0.3;
            }

            // ---------- IDLE ----------
            else {
                if (spine) spine.rotation.z = Math.sin(t * 2) * 0.02;
                if (head) head.rotation.z = Math.sin(t * 2) * 0.01;
                if (lArm) lArm.rotation.z = Math.sin(t * 2) * 0.01;
                if (rArm) rArm.rotation.z = -Math.sin(t * 2) * 0.01;
            }
        }

        // ========== MODEL LOADING ==========
        uploadBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['glb','gltf'].includes(ext)) { showToast('Unsupported format','error'); return; }
            if (file.size > 100*1024*1024) { showToast('File >100MB','error'); return; }
            const url = URL.createObjectURL(file);
            loadModel(url, file.name);
        });

        async function loadModel(url, name) {
            setStatus('Loading...', 'info');
            try {
                if (currentModel) scene.remove(currentModel);
                if (skeletonHelper) scene.remove(skeletonHelper);

                const loader = new GLTFLoader();
                const gltf = await new Promise((res, rej) => loader.load(url, res, undefined, rej));
                currentModel = gltf.scene;
                scene.add(currentModel);

                const box = new THREE.Box3().setFromObject(currentModel);
                const minY = box.min.y;
                currentModel.position.y -= minY;

                bones = [];
                currentModel.traverse(obj => { if (obj.isBone) bones.push(obj); });
                setStatus(`Loaded: ${name} (${bones.length} bones)`, 'success');
                diagBones.innerText = bones.length;
                diagModel.innerText = name;
                mapBtn.disabled = false;
                progressFill.style.width = '0%';
                diagProgress.innerText = '0%';
            } catch (err) {
                setStatus('Load failed', 'error');
                showToast(err.message, 'error');
            }
        }

        // ========== RESET SCENE ==========
        function resetScene() {
            if (currentModel) scene.remove(currentModel);
            currentModel = null;
            bones = [];
            boneMapping.clear();
            setStatus('Scene reset', 'success');
            diagBones.innerText = '0';
            diagModel.innerText = 'none';
            progressFill.style.width = '0%';
            diagProgress.innerText = '0%';
            mapBtn.disabled = true;
            animSelect.disabled = true;
            playAnimBtn.disabled = true;
            stopAnimBtn.disabled = true;
            animPlaying = false;
        }

        // ========== ANIMATION CONTROLS ==========
        playAnimBtn.addEventListener('click', () => {
            currentAnim = animSelect.value;
            animPlaying = true;
            animTime = 0;
            showToast(`Playing: ${currentAnim}`, 'success');
        });
        stopAnimBtn.addEventListener('click', () => {
            animPlaying = false;
            showToast('Animation stopped', 'info');
        });

        // ========== OTHER CONTROLS ==========
        resetBtn.addEventListener('click', resetScene);
        settingsBtn.addEventListener('click', () => {
            document.getElementById('diagnostic-panel').classList.remove('hidden');
        });
        zoomSlider.addEventListener('input', () => {
            const dist = parseFloat(zoomSlider.value);
            zoomValue.textContent = dist.toFixed(1);
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target.clone().add(direction.multiplyScalar(dist)));
            controls.update();
        });
        controls.addEventListener('change', () => {
            const dist = camera.position.distanceTo(controls.target);
            zoomSlider.value = dist.toFixed(1);
            zoomValue.textContent = dist.toFixed(1);
        });

        // Use the new async chunked mapping
        mapBtn.addEventListener('click', runMappingChunked);

        // ========== ANIMATION LOOP ==========
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            if (animPlaying) {
                applyAnimation(delta);
            }
            diagFps.innerText = Math.round(1 / delta) + ' fps';
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        setTimeout(() => document.getElementById('loading').classList.add('fadeout'), 2000);
    </script>
</body>
</html>
